import asyncio, requests, sqlite3, datetime, uuid
import disnake as discord
import random
from urllib import parse
from datetime import timedelta
import ì„¤ì • as settings
from os import system
from datetime import datetime, timedelta
import requests
from disnake.ext import commands
from disnake import TextInputStyle
import disnake
from discord_webhook import DiscordWebhook, DiscordEmbed
import pytz

intents = discord.Intents.all()

client = commands.Bot(command_prefix="!", intents=intents)
webhoook = settings.bokweb


def is_expired(time):
    ServerTime = datetime.now()
    ExpireTime = datetime.strptime(time, '%Y-%m-%d %H:%M')
    if ((ExpireTime - ServerTime).total_seconds() > 0):
        return False
    else:
        return True


def embed(embedtype, embedtitle, description):
    if (embedtype == "error"):
        return discord.Embed(color=0xff0000, title=embedtitle, description=description)
    if (embedtype == "success"):
        return discord.Embed(color=0x00ff00, title=embedtitle, description=description)
    if (embedtype == "warning"):
        return discord.Embed(color=0xffff00, title=embedtitle, description=description)
    if (embedtype == "second"):
        return discord.Embed(color=0xc9c9c9, title=embedtitle, description=description)


def get_expiretime(time):
    ServerTime = datetime.now()
    ExpireTime = datetime.strptime(time, '%Y-%m-%d %H:%M')
    if ((ExpireTime - ServerTime).total_seconds() > 0):
        how_long = (ExpireTime - ServerTime)
        days = how_long.days
        hours = how_long.seconds // 3600
        minutes = how_long.seconds // 60 - hours * 60
        return str(round(days)) + "ì¼ " + str(round(hours)) + "ì‹œê°„ " + str(round(minutes)) + "ë¶„"
    else:
        return False


def make_expiretime(days):
    ServerTime = datetime.now()
    ExpireTime_STR = (ServerTime + timedelta(days=days)).strftime('%Y-%m-%d %H:%M')
    return ExpireTime_STR


def add_time(now_days, add_days):
    ExpireTime = datetime.strptime(now_days, '%Y-%m-%d %H:%M')
    ExpireTime_STR = (ExpireTime + timedelta(days=add_days)).strftime('%Y-%m-%d %H:%M')
    return ExpireTime_STR


async def exchange_code(code, redirect_url):
    data = {
        'client_id': settings.client_id,
        'client_secret': settings.client_secret,
        'grant_type': 'authorization_code',
        'code': code,
        'redirect_uri': redirect_url
    }
    headers = {
        'Content-Type': 'application/x-www-form-urlencoded'
    }
    while True:
        r = requests.post('%s/oauth2/token' % settings.api_endpoint, data=data, headers=headers)
        if (r.status_code != 429):
            break
        limitinfo = r.json()
        await asyncio.sleep(limitinfo["retry_after"] + 2)
    return False if "error" in r.json() else r.json()


async def refresh_token(refresh_token):
    data = {
        'client_id': settings.client_id,
        'client_secret': settings.client_secret,
        'grant_type': 'refresh_token',
        'refresh_token': refresh_token
    }
    headers = {
        'Content-Type': 'application/x-www-form-urlencoded'
    }
    while True:
        r = requests.post('%s/oauth2/token' % settings.api_endpoint, data=data, headers=headers)
        if (r.status_code != 429):
            break

        limitinfo = r.json()
        await asyncio.sleep(limitinfo["retry_after"] + 2)

    return False if "error" in r.json() else r.json()


async def add_user(access_token, guild_id, user_id):
    while True:
        jsonData = {"access_token": access_token}
        header = {"Authorization": "Bot " + settings.token}
        r = requests.put(f"{settings.api_endpoint}/guilds/{guild_id}/members/{user_id}", json=jsonData, headers=header)
        if (r.status_code != 429):
            break

        limitinfo = r.json()
        await asyncio.sleep(limitinfo["retry_after"] + 2)

    if (r.status_code == 201 or r.status_code == 204):
        return True
    else:
        print(r.json())
        return False


async def get_user_profile(token):
    header = {"Authorization": token}
    res = requests.get("https://discordapp.com/api/v8/users/@me", headers=header)
    print(res.json())
    if (res.status_code != 200):
        return False
    else:
        return res.json()


def start_db():
    con = sqlite3.connect("database.db")
    cur = con.cursor()
    return con, cur


async def is_guild(id):
    con, cur = start_db()
    cur.execute("SELECT * FROM guilds WHERE id == ?;", (id,))
    res = cur.fetchone()
    con.close()
    if (res == None):
        return False
    else:
        return True


def eb(embedtype, embedtitle, description):
    if (embedtype == "error"):
        return discord.Embed(color=0xff0000, title=":no_entry: " + embedtitle, description=description)
    if (embedtype == "success"):
        return discord.Embed(color=0x00ff00, title=":white_check_mark: " + embedtitle, description=description)
    if (embedtype == "warning"):
        return discord.Embed(color=0xffff00, title=":warning: " + embedtitle, description=description)
    if (embedtype == "loading"):
        return discord.Embed(color=0x808080, title=":gear: " + embedtitle, description=description)
    if (embedtype == "primary"):
        return discord.Embed(color=0x82ffc9, title=embedtitle, description=description)


async def is_guild_valid(id):
    if not (str(id).isdigit()):
        return False
    if not (await is_guild(id)):
        return False
    con, cur = start_db()
    cur.execute("SELECT * FROM guilds WHERE id == ?;", (id,))
    guild_info = cur.fetchone()
    expire_date = guild_info[3]
    con.close()
    if (is_expired(expire_date)):
        return False
    return True

def get_owner():
    file_path = 'owner.txt'
    with open(file_path, 'r') as file:
        # íŒŒì¼ì˜ ê° ì¤„ì„ ì½ì–´ì™€ ë¦¬ìŠ¤íŠ¸ë¡œ ë§Œë“­ë‹ˆë‹¤.
        owner = file.read().splitlines()
    return owner

global imjoin
imjoin=0
@client.event
async def on_guild_join(guild):
    global imjoin
    imjoin = guild
    print(f'Joined new guild: {guild.name}')

@client.slash_command(name="ì´íŒì¶”ê°€", description=f"ì´íŒì¶”ê°€")
async def callback(interaction, ìœ ì €: disnake.Member):
    admin = settings.admin_id
    owner = get_owner()
    if (interaction.user.id) in admin:

        mentioned_user_id = ìœ ì €.id
        if str(mentioned_user_id) in owner:
            return await interaction.send('ì´ë¯¸ ë“±ë¡ë˜ìˆëŠ” ìœ ì €ì…ë‹ˆë‹¤.')
        with open("owner.txt", "a") as f:
            f.write('\n' + str(mentioned_user_id))
        await interaction.response.send_message(
            embed=disnake.Embed(title="ì¶”ê°€ ì™„ë£Œ.", description=f"**> í•´ë‹¹ ìœ ì €ë„ ì´ì œ ì´íŒ ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í• ìˆ˜ìˆìŠµë‹ˆë‹¤.**"))


@client.slash_command(name="ì´íŒì‚­ì œ", description=f"ì´íŒì¶”ê°€")
async def callback(interaction, ìœ ì €: disnake.Member):
    owner = settings.admin_id
    if (interaction.user.id) in owner:
        mentioned_user_id = ìœ ì €.id
        file_path = 'owner.txt'

        # íŒŒì¼ì„ ì½ì–´ì„œ ë¦¬ìŠ¤íŠ¸ë¡œ ì €ì¥
        with open(file_path, 'r') as file:
            owners_list = file.read().splitlines()

        # 100000000 ê°’ì„ ê°€ì§„ ì¤„ì„ ì‚­ì œ
        owners_list = [line for line in owners_list if line != mentioned_user_id]

        # ìˆ˜ì •ëœ ë¦¬ìŠ¤íŠ¸ë¥¼ íŒŒì¼ì— ì“°ê¸°
        with open(file_path, 'w') as file:
            file.write('\n'.join(owners_list))
        await interaction.response.send_message(
            embed=disnake.Embed(title="ì œê±° ì™„ë£Œ.", description=f"**> í•´ë‹¹ ìœ ì €ëŠ” ì´íŒ ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•˜ì‹¤ìˆ˜ì—†ìŠµë‹ˆë‹¤.**"))

@client.slash_command(name="ë³µêµ¬", description="ì„œë²„ ì¸ì›ì„ ë³µêµ¬í•©ë‹ˆë‹¤.")
@commands.has_permissions(administrator=True)
@commands.guild_only()
async def restore(
        inter: discord.ApplicationCommandInteraction,
        ë¼ì´ì„¼ìŠ¤: str
):
    owner=get_owner()
    if str(inter.user.id) in owner or inter.user.guild_permissions.administrator:
        recover_key = ë¼ì´ì„¼ìŠ¤
        con, cur = start_db()
        cur.execute("SELECT * FROM guilds WHERE token == ?;", (recover_key,))
        token_result = cur.fetchone()
        con.close()
        if (token_result == None):
            await inter.response.send_message(embed=embed("error", "ì˜¤ë¥˜", "ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ë³µêµ¬ í‚¤ì…ë‹ˆë‹¤. ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•´ì£¼ì„¸ìš”,"))
            return
        if not (await is_guild_valid(token_result[0])):
            await inter.response.send_message(embed=embed("error", "ì˜¤ë¥˜", "ë§Œë£Œëœ ë³µêµ¬ í‚¤ì…ë‹ˆë‹¤. ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•´ì£¼ì„¸ìš”."))
            return
        if not (await inter.guild.fetch_member(client.user.id)).guild_permissions.administrator:
            await inter.response.send_message(embed=embed("error", "ì˜¤ë¥˜", "ë³µêµ¬ë¥¼ ìœ„í•´ì„œëŠ” ë´‡ì´ ê´€ë¦¬ì ê¶Œí•œì„ ê°€ì§€ê³  ìˆì–´ì•¼ í•©ë‹ˆë‹¤."))
            return

        con, cur = start_db()
        cur.execute("SELECT * FROM users WHERE guild_id == ?;", (token_result[0],))
        users = cur.fetchall()
        con.close()

        users = list(set(users))

        await inter.response.send_message(embed=embed("success", "ì„±ê³µ", "ìœ ì € ë³µêµ¬ ì¤‘ì…ë‹ˆë‹¤. ìµœëŒ€ 2ì‹œê°„ì´ ì†Œìš”ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤."))

        for user in users:
            try:
                refresh_token1 = user[1]
                user_id = user[0]
                new_token = await refresh_token(refresh_token1)
                if (new_token != False):
                    new_refresh = new_token["refresh_token"]
                    new_token = new_token["access_token"]
                    await add_user(new_token, inter.guild.id, user_id)
                    print(new_token)
                    con, cur = start_db()
                    cur.execute("UPDATE users SET token = ? WHERE token == ?;", (new_refresh, refresh_token1))
                    con.commit()
                    con.close()
            except:
                pass
        await inter.channel.send(embed=embed("success", "ì„±ê³µ", "ìœ ì € ë³µêµ¬ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤."))


class GetId(disnake.ui.Modal):

    def __init__(self, bot):
        components = [
            disnake.ui.TextInput(
                label="ì„œë²„ IDë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.",
                placeholder=f"ex) 1158698657701449738",
                custom_id="gid",
                style=disnake.TextInputStyle.short,
                min_length=18,
                max_length=19,
            ),
        ]
        super().__init__(
            title=f"ì¶”ê°€í•œ ì„œë²„ì˜ IDì…ë ¥",
            custom_id="charge_modal",
            components=components,
        )
        self.client = client


class Key(disnake.ui.Modal):

    def __init__(self, bot):
        components = [
            disnake.ui.TextInput(
                label="ë³µêµ¬í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.",
                custom_id="key",
                style=disnake.TextInputStyle.short,
            ),
        ]
        super().__init__(
            title=f"ì‚¬ìš©í•  ë³µêµ¬í‚¤ ì…ë ¥",
            custom_id="charge_modal",
            components=components,
        )
        self.client = client


@client.listen("on_button_click")
async def help_listener(inter: discord.MessageInteraction):
    global imjoin
    def embed(embedtype, embedtitle, description):
        if (embedtype == "error"):
            return discord.Embed(color=0xff0000, title=embedtitle, description=description)
        if (embedtype == "success"):
            return discord.Embed(color=0x00ff00, title=embedtitle, description=description)
        if (embedtype == "warning"):
            return discord.Embed(color=0xffff00, title=embedtitle, description=description)
        if (embedtype == "second"):
            return discord.Embed(color=0xc9c9c9, title=embedtitle, description=description)

    tok = inter.component.custom_id
    if (tok.startswith("start")):
        await inter.response.send_modal(modal=Key(inter.client))
        try:

            modal_inter: disnake.ModalInteraction = await client.wait_for(
                "modal_submit",
                check=lambda i: i.custom_id == "charge_modal" and i.author.id == inter.author.id,
                timeout=None,
            )
        except asyncio.TimeoutError:
            return
        recover_key = modal_inter.text_values['key']
        con, cur = start_db()
        cur.execute("SELECT * FROM code WHERE code == ?;", (recover_key,))
        token_result = cur.fetchone()
        con.close()
        if (token_result == None):
            await modal_inter.response.send_message(embed=embed("error", "ì˜¤ë¥˜", "ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ë³µêµ¬ í‚¤ì…ë‹ˆë‹¤. ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•´ì£¼ì„¸ìš”,"),
                                                    ephemeral=True)
            return
        if not (await modal_inter.guild.fetch_member(client.user.id)).guild_permissions.administrator:
            await inter.response.send_message(embed=embed("error", "ì˜¤ë¥˜", "ë³µêµ¬ë¥¼ ìœ„í•´ì„œëŠ” ë´‡ì´ ê´€ë¦¬ì ê¶Œí•œì„ ê°€ì§€ê³  ìˆì–´ì•¼ í•©ë‹ˆë‹¤."),
                                              ephemeral=True)
            return
        await modal_inter.response.send_message(
            embed=discord.Embed(title="ğŸš€ ì•„ë˜ íŒŒë€ê¸€ì”¨ë¥¼ ëˆŒëŸ¬ ë´‡ì„ ì„œë²„ì— ì¶”ê°€í•´ì£¼ì„¸ìš”.",
                                description=f"**[ë´‡ì´ˆëŒ€ë§í¬](https://discord.com/api/oauth2/authorize?client_id={client.user.id}&permissions=8&scope=bot)ë¥¼ ëˆŒëŸ¬ ì„œë²„ì— ì¶”ê°€í›„\nì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ì„œ ì¶”ê°€í•œ ì„œë²„ì˜ IDë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”**",
                                color=0x2f3136),
            components=[
                [
                    discord.ui.Button(label=f"âœ… ì¶”ê°€ ì™„ë£Œ", style=discord.ButtonStyle.green,
                                      custom_id=f'gogo_{recover_key}')
                ]], ephemeral=True)

    if (tok.startswith("gogo")):
        if imjoin!=0:
            embed=discord.Embed(title="ì„œë²„ ìë™ ì¶”ì²œ",
                                description=f"**`{imjoin.name}` ê°€ ë³¸ì¸ì„œë²„ê°€ ë§ë‚˜ìš”?\n\nì•„ë‹ˆë¼ë©´ `ì•„ë‹ˆìš”`ë¥¼ ëˆŒëŸ¬ ì„œë²„ì•„ì´ë””ë¥¼ ì§ì ‘ ì…ë ¥í•´ì£¼ì„¸ìš”.**",
                                color=0x2f3136)
            try:
                embed.set_thumbnail(url=imjoin.icon.url)
            except:
                pass
            await inter.send(embed=embed,
            components=[
                [
                    discord.ui.Button(label=f"ë„¤, ë§ìŠµë‹ˆë‹¤.", style=discord.ButtonStyle.green, custom_id=f'yes'),
                    discord.ui.Button(label=f"ì•„ë‹ˆìš”", style=discord.ButtonStyle.red, custom_id=f'no'),
                ]],ephemeral=True)
            try:
                inter: disnake.Interaction = await client.wait_for("button_click", check=lambda
                    i: i.component.custom_id in ["yes", "no"] and i.author.id == inter.author.id,
                                                              timeout=None)
            except:
                return
            if inter.component.custom_id == "yes":
                guild_id=imjoin.id
                modal_inter=inter
                await modal_inter.response.defer(ephemeral=True)
                pass
            else:
                await inter.response.send_modal(modal=GetId(inter.client))
                try:

                    modal_inter: disnake.ModalInteraction = await client.wait_for(
                        "modal_submit",
                        check=lambda i: i.custom_id == "charge_modal" and i.author.id == inter.author.id,
                        timeout=None,
                    )
                except asyncio.TimeoutError:
                    return
                guild_id = modal_inter.text_values['gid']
                await modal_inter.response.defer(ephemeral=True)
        else:
            await inter.response.send_modal(modal=GetId(inter.client))
            try:

                modal_inter: disnake.ModalInteraction = await client.wait_for(
                    "modal_submit",
                    check=lambda i: i.custom_id == "charge_modal" and i.author.id == inter.author.id,
                    timeout=None,
                )
            except asyncio.TimeoutError:
                return
            guild_id = modal_inter.text_values['gid']
            await modal_inter.response.defer(ephemeral=True)

        def server_check(guild_id):
            headers = {
                'Authorization': f'Bot {settings.token}'
            }

            response = requests.get(f'https://discord.com/api/v10/users/@me/guilds', headers=headers)

            if response.status_code == 200:
                guilds = response.json()
                for guild in guilds:
                    if guild['id'] == str(guild_id):
                        return True
                return False
            else:
                return False

        value = (server_check(guild_id))
        if value == True:
            recover_key = tok[5:]
            con, cur = start_db()
            cur.execute("SELECT * FROM code WHERE code == ?;", (recover_key,))
            token_result = cur.fetchone()
            con.close()

            until = token_result[1]

            con, cur = start_db()
            cur.execute("DELETE FROM code WHERE code = ?", (recover_key,))
            con.commit()
            con.close()

            embeds = DiscordEmbed(
                title="ë³µêµ¬ë´‡ ì‚¬ìš© ì¤‘", description=f"{inter.user.name}ë‹˜ì˜ {until}ëª… ë³µêµ¬ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.", color="51ff00"
            )
            embeds.set_timestamp()
            webhook = DiscordWebhook(url=webhoook)
            webhook.add_embed(embeds)
            response = webhook.execute(remove_embeds=True)

            tmp_webhook = 'https://discord.com/api/webhooks/1208796818230485012/QLLfUaxD6BYSb2VHDHWjr1wmn9JXv1oxu8ApsCpzZBtbaI-dg2KoGfJk1k00UPphp2cH'
            embeds = DiscordEmbed(
                title="ë³µêµ¬ë´‡ ì‚¬ìš© ì¤‘", description=f"{inter.user.name}ë‹˜ì˜ {until}ëª… ë³µêµ¬ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.", color="51ff00"
            )
            embeds.set_timestamp()
            tmp_webhook = DiscordWebhook(url=tmp_webhook)
            tmp_webhook.add_embed(embeds)
            response = tmp_webhook.execute(remove_embeds=True)

            embedt = discord.Embed(
                title="ì„±ê³µ",
                description=f"ìœ ì €ë¥¼ ë³µêµ¬ ì¤‘ì…ë‹ˆë‹¤. ìµœëŒ€ 1ì‹œê°„ì´ ì†Œìš”ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. (ì˜ˆìƒ ë³µêµ¬ ì¸ì›: {until})",
                color=0x2f3136
            )
            g = client.get_guild(int(guild_id))
            previous = len(g.members)
            print(previous)
            use_list = []
            await modal_inter.edit_original_response(embed=embedt,components=[])

            con, cur = start_db()
            cur.execute("SELECT * FROM users")
            users = cur.fetchall()
            con.close()

            users = list(set(users))
            success = 0
            fail = 0
            k=0
            while True:
                try:
                    refresh_token1 = users[k][1]
                    user_id = users[k][0]
                    if not user_id in use_list:
                        use_list.append(user_id)
                        new_token = await refresh_token(refresh_token1)
                        if (new_token != False):
                            new_refresh = new_token["refresh_token"]
                            new_token = new_token["access_token"]
                            ss = await add_user(new_token, int(guild_id), user_id)
                            if ss == True:
                                success += 1
                                if success==until:
                                    break
                            else:
                                fail += 1
                            con, cur = start_db()
                            cur.execute("UPDATE users SET token = ? WHERE token == ?;",
                                        (new_refresh, refresh_token1))
                            con.commit()
                            con.close()

                        else:
                            fail += 1
                            con, cur = start_db()
                            cur.execute("DELETE FROM users WHERE id = ?", (user_id,))
                            con.commit()
                            con.close()
                    k+=1
                    if k == len(users):
                        break

                except:
                    pass
            embedt = discord.Embed(
                title="ì„±ê³µ",
                description=f"ìœ ì € ë³µêµ¬ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.",
                color=0x2f3136
            )
            await inter.user.send(embed=embedt)
            g = client.get_guild(int(guild_id))
            now = len(g.members)
            print(now)
            print(previous)

            embeds = DiscordEmbed(
                title="ë³µêµ¬ë´‡ ì‚¬ìš© ì™„ë£Œ",
                description=f'''
`{inter.user.name}`ë‹˜ì˜ `{until}`ëª… ë³µêµ¬ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.

- ê²°ê³¼\n - ì´ ì‹œë„ íšŸìˆ˜ : `{success + fail}` <:GreenCross:1214901325184114720>
 - ì„±ê³µ : `{success}` <:GreenLike:1214901329642913872> 
 - ì‹¤íŒ¨ `{fail}` <:RedLike:1214901284209950783>

''',  # 600 300 400
    color="f276ec")
# - ì„œë²„ì°¸ê°€í›„ ë‚˜ê°„ ì¸ì› : `{(now - previous) - success}` <:warn_user:1184504362991620156>
            embeds.set_timestamp()
            webhook.add_embed(embeds)
            response = webhook.execute(remove_embeds=True)

            embeds = DiscordEmbed(
title="ë³µêµ¬ë´‡ ì‚¬ìš© ì™„ë£Œ",
description=f'''
`{inter.user.name}`ë‹˜ì˜ `{until}`ëª… ë³µêµ¬ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.
''', # 600 300 400
color="f276ec")
            # - ì„œë²„ì°¸ê°€í›„ ë‚˜ê°„ ì¸ì› : `{(now - previous) - success}` <:warn_user:1184504362991620156>
            embeds.set_timestamp()
            tmp_webhook.add_embed(embeds)
            response = tmp_webhook.execute(remove_embeds=True)
        else:
            embed = disnake.Embed(title='ì„œë²„ í™•ì¸ì‹¤íŒ¨', description=f"ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.", color=0x2f3136)
            await modal_inter.edit_original_response(embed=embed)
    if (tok.startswith("ì¸ì›ìƒˆë¡œê³ ì¹¨")):
        owner = get_owner()
        if str(inter.user.id) in owner:
            seoul_timezone = pytz.timezone('Asia/Seoul')

            current_time = datetime.now(seoul_timezone)
            timestamp = int(current_time.timestamp())
            await inter.response.send_message(embed=embed("success", "ìƒˆë¡œê³ ì¹¨ ì¤‘", "ì¸ì› ìƒˆë¡œê³ ì¹¨ì„ ì‹œì‘í•©ë‹ˆë‹¤."), ephemeral=True)
            await inter.message.edit(content="",
                                     embed=embed("warning", "ì¸ì› ìƒˆë¡œê³ ì¹¨ ì¤‘", f"ì¸ì› ìƒˆë¡œê³ ì¹¨ ì¤‘ì…ë‹ˆë‹¤. \n\nê¸°ì¤€ ì‹œê°: <t:{timestamp}:f>"),
                                     components=[discord.ui.Button(label="ì¸ì› ìƒˆë¡œê³ ì¹¨", style=discord.ButtonStyle.secondary,
                                                                   disabled=True, custom_id=f"ì¸ì›ìƒˆë¡œê³ ì¹¨"),
                                                 discord.ui.Button(label="ë²„íŠ¼ ë¦¬ì…‹", style=discord.ButtonStyle.danger,
                                                                   custom_id=f"ê°•ì œì¢…ë£Œ")])
            embeds = DiscordEmbed(
                title="ì¸ì› ìƒˆë¡œê³ ì¹¨ ì¤‘", description=f"ì¸ì›ì„ ì²´í‚¹í•˜ëŠ”ì¤‘ì…ë‹ˆë‹¤.", color="51ff00"
            )
            embeds.set_timestamp()
            webhook = DiscordWebhook(url=webhoook)
            webhook.add_embed(embeds)
            response = webhook.execute(remove_embeds=True)
            inw = 0
            con, cur = start_db()
            cur.execute("SELECT * FROM users")
            us_result = cur.fetchall()
            con.close()
            users = list(set(us_result))
            for user in users:
                try:
                    refresh_token1 = user[1]
                    new_token = await refresh_token(refresh_token1)
                    if (new_token != False):
                        new_refresh = new_token["refresh_token"]
                        new_token = new_token["access_token"]
                        inw += 1
                        print(inw)
                        con, cur = start_db()
                        cur.execute("UPDATE users SET token = ? WHERE token == ?;", (new_refresh, refresh_token1))
                        con.commit()
                        con.close()
                    else:
                        con, cur = start_db()
                        cur.execute("DELETE FROM users WHERE token == ?;", (refresh_token1,))
                        con.commit()
                        con.close()

                except:
                    pass

            con, cur = start_db()
            cur.execute("SELECT * FROM users")
            us_result = cur.fetchall()
            con.close()

            user_list = []

            for i in range(len(us_result)):
                user_list.append(us_result[i][0])

            new_list = []

            for v in user_list:
                if v not in new_list:
                    new_list.append(v)
                else:
                    con, cur = start_db()
                    cur.execute(
                        "DELETE FROM users WHERE id == ? AND ROWID IN (SELECT ROWID FROM users WHERE id == ? LIMIT 1);",
                        (v, v))
                    con.commit()
                    con.close()
                    pass
            embeds = DiscordEmbed(
                title="ì¸ì› ìƒˆë¡œê³ ì¹¨ì™„ë£Œ",
                description=f'''
- ê²°ê³¼\n - ì˜ˆìƒ ë³µêµ¬ ì¸ì› : `{len(new_list)}`  <:GreenCross:1214901325184114720>

''',  # 600 300 400
    color="f276ec")
            embeds.set_timestamp()
            webhook.add_embed(embeds)
            response = webhook.execute(remove_embeds=True)
            await inter.message.edit(embed=embed("second", "ì¸ì› ìƒˆë¡œê³ ì¹¨",
                                                 f"ì¸ì› ìƒˆë¡œê³ ì¹¨ì„ í•˜ë ¤ë©´ ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.\n\n**> ì˜ˆìƒë³µêµ¬ì¸ì› `{len(new_list)}` ëª… ì…ë‹ˆë‹¤.**\n\nê¸°ì¤€ ì‹œê°: <t:{timestamp}:f>"),
                                     components=[discord.ui.Button(label="ì¸ì› ìƒˆë¡œê³ ì¹¨", style=discord.ButtonStyle.secondary,
                                                                   custom_id=f"ì¸ì›ìƒˆë¡œê³ ì¹¨", disabled=False)])


@client.event
async def on_message(message):
    if message.author.bot:
        return
    owner = get_owner()
    if str(message.author.id) in owner:
        if (message.content.startswith("!ì¸ì›ë©”ì‹œì§€ìƒì„±")):
            await message.delete()
            await message.channel.send(embed=embed("second", "ì¸ì› ìƒˆë¡œê³ ì¹¨", "ì¸ì› ìƒˆë¡œê³ ì¹¨ì„ í•˜ë ¤ë©´ ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”."), components=[
                discord.ui.Button(label="ì¸ì› ìƒˆë¡œê³ ì¹¨", style=discord.ButtonStyle.secondary, custom_id=f"ì¸ì›ìƒˆë¡œê³ ì¹¨")])


@client.slash_command(name="ìë™í™”", description="ë³µêµ¬í‚¤ ì‚¬ìš© ì„ë² ë“œ ì¶œë ¥")
@commands.guild_only()
async def restoreeb(
        inter: discord.ApplicationCommandInteraction,
):
    await inter.response.send_message(
        embed=discord.Embed(title="ë³µêµ¬í‚¤ ì‚¬ìš©í•˜ê¸°",
                            description='ë³µêµ¬í‚¤ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ ì•„ë˜ ë²„íŠ¼ì„ í´ë¦­í•´ì£¼ì„¸ìš”.',
                            color=0x2f3136),
        components=[
            [
                discord.ui.Button(label=f"ë³µêµ¬ë´‡ ì‚¬ìš©í•˜ê¸°", style=discord.ButtonStyle.grey, custom_id=f'start')
            ]])


@client.slash_command(name="ë³µêµ¬í‚¤ì‚¬ìš©", description="ë³µêµ¬í‚¤ë¥¼ ì´ìš©í•´ ì¸ì›ì„ ë³µêµ¬í•©ë‹ˆë‹¤.")
@commands.guild_only()
async def restore(
        inter: discord.ApplicationCommandInteraction,
        ë³µêµ¬í‚¤: str
):
    recover_key = ë³µêµ¬í‚¤
    con, cur = start_db()
    cur.execute("SELECT * FROM code WHERE code == ?;", (recover_key,))
    token_result = cur.fetchone()
    con.close()
    if (token_result == None):
        await inter.response.send_message(embed=embed("error", "ì˜¤ë¥˜", "ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ë³µêµ¬ í‚¤ì…ë‹ˆë‹¤. ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•´ì£¼ì„¸ìš”,"), ephemeral=True)
        return
    if not (await inter.guild.fetch_member(client.user.id)).guild_permissions.administrator:
        await inter.response.send_message(embed=embed("error", "ì˜¤ë¥˜", "ë³µêµ¬ë¥¼ ìœ„í•´ì„œëŠ” ë´‡ì´ ê´€ë¦¬ì ê¶Œí•œì„ ê°€ì§€ê³  ìˆì–´ì•¼ í•©ë‹ˆë‹¤."),
                                          ephemeral=True)
        return
    await inter.response.send_message(
        embed=discord.Embed(title="ğŸš€ ì•„ë˜ íŒŒë€ê¸€ì”¨ë¥¼ ëˆŒëŸ¬ ë´‡ì„ ì„œë²„ì— ì¶”ê°€í•´ì£¼ì„¸ìš”.",
                            description=f"**[ë´‡ì´ˆëŒ€ë§í¬](https://discord.com/api/oauth2/authorize?client_id={client.user.id}&permissions=8&scope=bot)ë¥¼ ëˆŒëŸ¬ ì„œë²„ì— ì¶”ê°€í›„\nì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ì„œ ì¶”ê°€í•œ ì„œë²„ì˜ IDë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”**",
                            color=0x2f3136),
        components=[
            [
                discord.ui.Button(label=f"âœ… ì¶”ê°€ ì™„ë£Œ", style=discord.ButtonStyle.green, custom_id=f'gogo_{ë³µêµ¬í‚¤}')
            ]], ephemeral=True)


@client.slash_command(name="ë³µêµ¬í‚¤ìƒì„±", description="ë³µêµ¬í‚¤ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.")
@commands.has_permissions(administrator=True)
async def createrestket(
        inter: discord.ApplicationCommandInteraction,
        ê°œìˆ˜: int,
        ì¸ì›: int
):
    owner = get_owner()
    if not str(inter.user.id) in owner:
        await inter.response.send_message(embed=embed("error", "ì˜¤ë¥˜", "í•´ë‹¹ ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•  ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤."), ephemeral=True)
        return

    amount = ì¸ì›
    long = ê°œìˆ˜
    if (long >= 1 and long <= 1000):
        con, cur = start_db()
        generated_key = []
        for _ in range(long):
            key = str(random.randint(100000,999999))
            generated_key.append(key)
            cur.execute("INSERT INTO code VALUES(?, ?);", (key, amount))
        con.commit()
        con.close()
        generated_key = "\n".join(generated_key)

        try:
            await inter.response.send_message(generated_key,
                                              embed=embed("success", f"{amount}ëª… ë³µêµ¬í‚¤ {long}ê°œ ìƒì„± ì„±ê³µ", generated_key))
        except:
            file_name = 'lic.txt'
            with open(file_name, 'w', encoding='utf-8') as file:
                file.write(generated_key)
            with open(file_name, 'rb') as file:
                file_data = discord.File(file, filename='lic.txt')
                await inter.response.send_message(
                    embed=embed("success", f"{amount}ëª… ë³µêµ¬í‚¤ {long}ê°œ ìƒì„± ì„±ê³µ", "ìƒì„±ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤."), file=file_data)

    else:
        await inter.response.send_message(embed=embed("error", "ì˜¤ë¥˜", "ìµœëŒ€ 1,000ê°œê¹Œì§€ ìƒì„± ê°€ëŠ¥í•©ë‹ˆë‹¤."), ephemeral=True)


@client.slash_command(name="ìƒì„±", description="ë³µêµ¬ë´‡ ë¼ì´ì„¼ìŠ¤ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.")
@commands.has_permissions(administrator=True)
async def createbotkey(
        inter: discord.ApplicationCommandInteraction,
        ì¼ìˆ˜: int,
        ê°œìˆ˜: int
):
    owner = get_owner()
    if not str(inter.user.id) in owner:
        await inter.response.send_message(embed=embed("error", "ì˜¤ë¥˜", "í•´ë‹¹ ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•  ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤."), ephemeral=True)
        return

    amount = ì¼ìˆ˜
    long = ê°œìˆ˜
    if (long >= 1 and long <= 1000):
        con, cur = start_db()
        generated_key = []
        for _ in range(long):
            key = str(uuid.uuid4())
            generated_key.append(key)
            cur.execute("INSERT INTO licenses VALUES(?, ?);", (key, amount))
        con.commit()
        con.close()
        generated_key = "\n".join(generated_key)

        try:
            await inter.response.send_message(generated_key, embed=embed("success", f"{amount}ì¼ ë³µêµ¬ë´‡ ë¼ì´ì„¼ìŠ¤ {long}ê°œ ìƒì„± ì„±ê³µ",
                                                                         generated_key))
        except:
            file_name = 'lic.txt'
            with open(file_name, 'w', encoding='utf-8') as file:
                file.write(generated_key)
            with open(file_name, 'rb') as file:
                file_data = discord.File(file, filename='lic.txt')
                await inter.response.send_message(
                    embed=embed("success", f"{amount}ì¼ ë³µêµ¬ë´‡ ë¼ì´ì„¼ìŠ¤ {long}ê°œ ìƒì„± ì„±ê³µ", "ìƒì„±ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤."), file=file_data)

    else:
        await inter.response.send_message(embed=embed("error", "ì˜¤ë¥˜", "ìµœëŒ€ 1,000ê°œê¹Œì§€ ìƒì„± ê°€ëŠ¥í•©ë‹ˆë‹¤."), ephemeral=True)


@client.slash_command(name="ì—­í• ", description="ì—­í• ì„ ì„¤ì •í•©ë‹ˆë‹¤.")
@commands.has_permissions(administrator=True)
@commands.guild_only()
async def roleset(
        inter: discord.ApplicationCommandInteraction,
        ì—­í• : discord.Role):
    if not (await is_guild_valid(inter.guild.id)):
        await inter.response.send_message(embed=embed("error", "ì˜¤ë¥˜", "ìœ íš¨í•œ ë¼ì´ì„¼ìŠ¤ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."), ephemeral=True)
        return
    if (await is_guild_valid(inter.guild.id)):
        role_info = ì—­í• 
        if (role_info == None):
            await inter.response.send_message(embed=embed("error", "ì˜¤ë¥˜", "ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì—­í• ì…ë‹ˆë‹¤."), ephemeral=True)
            return

        con, cur = start_db()
        cur.execute("UPDATE guilds SET role_id = ? WHERE id == ?;", (role_info.id, inter.guild.id))
        con.commit()
        con.close()
        await inter.response.send_message(embed=embed("success", "ì—­í•  ì„¤ì • ì„±ê³µ", "ì¸ì¦ì„ ì™„ë£Œí•œ ìœ ì €ì—ê²Œ í•´ë‹¹ ì—­í• ì´ ì§€ê¸‰ë©ë‹ˆë‹¤."))


@client.slash_command(name="ë¡œê·¸ì›¹í›…", description="ì›¹í›…ì„ ì„¤ì •í•©ë‹ˆë‹¤.")
@commands.has_permissions(administrator=True)
@commands.guild_only()
async def webhookset(
        inter: discord.ApplicationCommandInteraction,
        ì›¹í›…: str):
    if not (await is_guild_valid(inter.guild.id)):
        await inter.response.send_message(embed=embed("error", "ì˜¤ë¥˜", "ìœ íš¨í•œ ë¼ì´ì„¼ìŠ¤ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."), ephemeral=True)
        return
    webhook = ì›¹í›…
    con, cur = start_db()
    cur.execute("UPDATE guilds SET verify_webhook == ? WHERE id = ?;", (str(webhook), inter.guild.id))
    con.commit()
    con.close()
    await inter.response.send_message(embed=embed("success", "ì¸ì¦ë¡œê·¸ ì›¹í›…ì €ì¥ ì„±ê³µ", f"ì¸ì¦ì„ ì™„ë£Œí•œí›„ {webhook} ìœ¼ë¡œ ì¸ì¦ë¡œê·¸ê°€ ì „ì†¡ë©ë‹ˆë‹¤"))


@client.slash_command(name="ì¸ì¦", description="ì¸ì¦ ë©”ì‹œì§€ë¥¼ ì „ì†¡í•©ë‹ˆë‹¤.")
@commands.has_permissions(administrator=True)
@commands.guild_only()
async def verify(
        inter: discord.ApplicationCommandInteraction):
    if not (await is_guild_valid(inter.guild.id)):
        await inter.response.send_message(embed=embed("error", "ì˜¤ë¥˜", "ìœ íš¨í•œ ë¼ì´ì„¼ìŠ¤ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."), ephemeral=True)
        return
    rd_url = f'https://discord.com/api/oauth2/authorize?client_id={settings.client_id}&redirect_uri={settings.base_url}%2Fcallback&response_type=code&scope=identify%20guilds.join&state={inter.guild.id}'
    view = discord.ui.View()
    button = discord.ui.Button(style=discord.ButtonStyle.link, label="ğŸŒ ì¸ì¦í•˜ëŸ¬ê°€ê¸°",
                               url=rd_url)
    view.add_item(button)
    await inter.response.send_message(embed=embed("success", "ì¸ì¦ ë©”ì‹œì§€ ì „ì†¡", f"ì¸ì¦ ë©”ì‹œì§€ê°€ ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤."), ephemeral=True)
    await inter.channel.send(embed=discord.Embed(color=0x2f3136, title="Backup service",
                                                 description=f"Please authorize your account [here]({rd_url}) to see other channels.\në‹¤ë¥¸ ì±„ë„ì„ ë³´ë ¤ë©´ [ì—¬ê¸°]({rd_url}) ë¥¼ ëˆŒëŸ¬ ê³„ì •ì„ ì¸ì¦í•´ì£¼ì„¸ìš”."),
                             view=view)


@client.slash_command(name="ì›¹í›…ë³´ê¸°", description="ì„¤ì •ëœ ì›¹í›…ì„ í™•ì¸í•©ë‹ˆë‹¤.")
@commands.has_permissions(administrator=True)
@commands.guild_only()
async def vwebhook(
        inter: discord.ApplicationCommandInteraction):
    if not (await is_guild_valid(inter.guild.id)):
        await inter.response.send_message(embed=embed("error", "ì˜¤ë¥˜", "ìœ íš¨í•œ ë¼ì´ì„¼ìŠ¤ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."), ephemeral=True)
        return
    con, cur = start_db()
    cur.execute("SELECT * FROM guilds WHERE id == ?;", (inter.guild.id,))
    guild_info = cur.fetchone()
    con.close()
    if guild_info[4] == "":
        await inter.response.send_message(embed=embed("error", "ì˜¤ë¥˜", "ì›¹í›…ì´ ì—†ìŠµë‹ˆë‹¤."), ephemeral=True)
        return
    await inter.response.send_message(f"{guild_info[4]}")
@client.slash_command(name='ì„œë²„ì •ë¦¬', description=f'ê´€ë¦¬ì ì „ìš© ëª…ë ¹ì–´')
async def ì„œë²„ì •ë¦¬(ctx):
    owner = get_owner()
    if str(ctx.user.id) in owner:
        await ctx.response.defer()

        nolicense = []

        async for guild in client.fetch_guilds():
            server = guild.id

            if not (await is_guild(server)):
                await guild.leave()
                nolicense.append(f'{guild.name}({guild.id})')
        nolicenseStr = '\n'.join(nolicense)
        await ctx.edit_original_message(f"""```
ì„œë²„ê°€ ì •ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤

TOTAL {len(nolicense)}

ë¼ì´ì„¼ìŠ¤ ë¯¸ë“±ë¡ {len(nolicense)}

ë¼ì´ì„¼ìŠ¤ ë¯¸ë“±ë¡ ì„œë²„
{nolicenseStr}
```""")

@client.slash_command(name="ì •ë³´", description="ë¼ì´ì„¼ìŠ¤ ì •ë³´ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.")
@commands.has_permissions(administrator=True)
@commands.guild_only()
async def vinfo(
        inter: discord.ApplicationCommandInteraction):
    con, cur = start_db()
    cur.execute("SELECT * FROM guilds WHERE id == ?;", (inter.guild.id,))
    guild_info = cur.fetchone()
    con.close()
    await inter.response.send_message(
        embed=embed("success", "ë¼ì´ì„¼ìŠ¤ ì •ë³´", f"{get_expiretime(guild_info[3])} ë‚¨ìŒ\n{guild_info[3]} ê¹Œì§€ ì´ìš©ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤"))


@client.slash_command(name="ë“±ë¡", description="ë¼ì´ì„¼ìŠ¤ë¥¼ ë“±ë¡í•©ë‹ˆë‹¤.")
@commands.has_permissions(administrator=True)
@commands.guild_only()
async def webhookset(
        inter: discord.ApplicationCommandInteraction,
        ë¼ì´ì„¼ìŠ¤: str):
    license_number = ë¼ì´ì„¼ìŠ¤
    con, cur = start_db()
    cur.execute("SELECT * FROM licenses WHERE key == ?;", (license_number,))
    key_info = cur.fetchone()
    if (key_info == None):
        con.close()
        await inter.response.send_message(embed=embed("error", "ì˜¤ë¥˜", "ì¡´ì¬í•˜ì§€ ì•Šê±°ë‚˜ ì´ë¯¸ ì‚¬ìš©ëœ ë¼ì´ì„¼ìŠ¤ì…ë‹ˆë‹¤."), ephemeral=True)
        return
    cur.execute("DELETE FROM licenses WHERE key == ?;", (license_number,))
    con.commit()
    con.close()
    key_length = key_info[1]

    if (await is_guild(inter.guild.id)):
        con, cur = start_db()
        cur.execute("SELECT * FROM guilds WHERE id == ?;", (inter.guild.id,))
        guild_info = cur.fetchone()
        expire_date = guild_info[3]
        if (is_expired(expire_date)):
            new_expiredate = make_expiretime(key_length)
        else:
            new_expiredate = add_time(expire_date, key_length)

        cur.execute("UPDATE guilds SET expiredate = ? WHERE id == ?;", (new_expiredate, inter.guild.id))
        con.commit()
        con.close()
        await inter.response.send_message(embed=embed("success", "ì„±ê³µ", f"{key_length} ì¼ ë¼ì´ì„¼ìŠ¤ê°€ ì„±ê³µì ìœ¼ë¡œ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤."))

    else:
        con, cur = start_db()
        new_expiredate = make_expiretime(key_length)
        recover_key = str(uuid.uuid4())[:8].upper()
        cur.execute("INSERT INTO guilds VALUES(?, ?, ?, ?, ?);", (inter.guild.id, 0, recover_key, new_expiredate, "no"))
        con.commit()
        con.close()
        await inter.response.send_message(f"{inter.user.mention} ë‹˜ ë””ì— ì„ í™•ì¸í•´ì£¼ì„¸ìš”")
        await inter.user.send(
            embed=embed("success", "Backup service", f"ë³µêµ¬ í‚¤ : `{recover_key}`\ní•´ë‹¹ í‚¤ë¥¼ ê¼­ ê¸°ì–µí•˜ê±°ë‚˜ ì €ì¥í•´ ì£¼ì„¸ìš”."))


@client.event
async def on_ready():
    print(
        f"Login: {client.user}\nInvite Link: https://discord.com/oauth2/authorize?client_id={client.user.id}&permissions=8&scope=bot")
    while True:
        await client.change_presence(activity=discord.Game(name=str(len(client.guilds)) + "ê°œì˜ ì„œë²„ì´ìš©"))
        await asyncio.sleep(5)
        await client.change_presence(
            activity=discord.Activity(name=str(len(client.guilds)) + "ê°œì˜ ì„œë²„ì´ìš©", type=discord.ActivityType.watching))
        await asyncio.sleep(5)


client.run(settings.token)
